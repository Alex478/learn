## 2 курс - структуры данных
## скобочная последовательность

B = list(input()) # список скобок
def bracket(stroka):
    # проверяет скобочную последовательность (весь список)
     #   если скобочная последовтаельность неправильная, выводит
      #  номер первой неверной закрывающей скобки 
    stack = []
    idx = []
    k=0
    for i in stroka:
        k += 1
        if i in ('(','[','{'):# для откр.скобки
            stack.append(i)
            idx.append(k)
        else:                 # для закрыв.скобки
            if i not in (')',']','}'):
                continue
            elif len(stack) == 0:
                return print(k)
            elif (stack[-1] in ("(") and i in (")")) or ( stack[-1] in ('[') and i in (']')) or ( stack[-1] in ('{') and i in ('}')):
                stack.pop()
                idx.pop()
    if len(stack) == 0:
        return print('Success')
    pos = stack.pop()
    return print(idx[0])
bracket(B)

# высота дерева

n = int(input())
B = list(map(int, input().split()))
m_height = [None] * n # массив для значений высоты
def get_height(p): 
    # p- значение/родитель
    if m_height[p] is not None: # если уже посчитано/есть значение
        return m_height[p] 
    if p == -1: # если значение =-1 это корень 
        return 1 # вернуть 1
    h = 1 + get_height(B[p]) #
    m_height[p] = h # высота 
    return h
mx = 0
for i in B: # поиск высоты для каждого элемента вх.списка
    h = get_height(i)
    mx = max(h, mx) #
print(mx)

# симуляция обработки сетевых пакетов
import bisect
size, n = map(int, input().split())
M_bufer = [] # массив для времени выхода
for i in range(n):
    time_in, time_size = map(int, input().split())
    del M_bufer[0:bisect.bisect(M_bufer, time_in)]# очистить буфер/удалить все пакеты с меньшим временем
    if len(M_bufer) < size: # если буфер не полный 
        if M_bufer: # если в буфере что то есть, то сравниваем время
            otvet = max(M_bufer[-1], time_in)# if M_bufer 
        else:
            otvet = time_in
        print(otvet)
        M_bufer.append(otvet + time_size)
    else: # если буфер полный
        print(-1)
        
## стек с поддержкой максимума
Stack = [] #
q = int(input())
max_stack = 0 # максим элемент
for i in range(q): 
    elem = input() 
    if elem.startswith("push"): # добавляем элемент
        a = int(elem.split("push ")[1]) # выделяем число из введенной строки
        w = max(max_stack, a)       # выбираем максимум из элемента и сохраненного числа
        Stack.append(w)
        max_stack = w
    elif elem.startswith("pop"): # удаляем последний добавленный элемент
        Stack.pop()
        if len(Stack) == 0: # если пуст стек то нуль
            max_stack = 0
        else:
            max_stack = Stack[-1] # либо равен последнему элементу в стеке
    elif elem.startswith("max"): # если мах 
        print(Stack[-1])      # то печатаем последний элемент
        
## максимум в скользящем окне

